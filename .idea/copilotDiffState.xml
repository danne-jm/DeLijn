<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/AndroidManifest.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/AndroidManifest.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#10;&#10;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot; /&gt;&#10;&#10;    &lt;application&#10;        android:name=&quot;.DeLijnApp&quot;&#10;        android:allowBackup=&quot;true&quot;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/Theme.DeLijn&quot;&gt;&#10;        &lt;activity&#10;            android:name=&quot;.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:label=&quot;@string/app_name&quot;&#10;            android:theme=&quot;@style/Theme.DeLijn&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;    &lt;/application&gt;&#10;&#10;&lt;/manifest&gt;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#10;&#10;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot; /&gt;&#10;&#10;    &lt;application&#10;        android:name=&quot;.DeLijnApp&quot;&#10;        android:allowBackup=&quot;true&quot;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/Theme.DeLijn&quot;&gt;&#10;        &lt;activity&#10;            android:name=&quot;.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:label=&quot;@string/app_name&quot;&#10;            android:theme=&quot;@style/Theme.DeLijn&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;    &lt;/application&gt;&#10;&#10;&lt;/manifest&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/danieljm/delijn/ui/screens/stops/StopsScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/danieljm/delijn/ui/screens/stops/StopsScreen.kt" />
              <option name="originalContent" value="package com.danieljm.delijn.ui.screens.stops&#10;&#10;import android.Manifest&#10;import android.app.Activity&#10;import android.content.Context&#10;import android.content.pm.PackageManager&#10;import android.location.Location&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.viewinterop.AndroidView&#10;import androidx.core.content.ContextCompat&#10;import com.google.android.gms.location.LocationServices&#10;import org.koin.androidx.compose.koinViewModel&#10;import org.osmdroid.config.Configuration&#10;import org.osmdroid.tileprovider.tilesource.TileSourceFactory&#10;import org.osmdroid.util.GeoPoint&#10;import org.osmdroid.views.MapView&#10;import org.osmdroid.views.overlay.Marker&#10;import com.danieljm.delijn.R&#10;import com.danieljm.delijn.ui.components.BottomSheet&#10;&#10;@Composable&#10;fun StopsScreen(&#10;    viewModel: StopsViewModel = koinViewModel()&#10;) {&#10;    val context = LocalContext.current&#10;    val activity = context as? Activity&#10;&#10;    // Track permission state&#10;    var hasLocationPermission by remember {&#10;        mutableStateOf(&#10;            ContextCompat.checkSelfPermission(context, Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED&#10;        )&#10;    }&#10;&#10;    val permissionLauncher = rememberLauncherForActivityResult(&#10;        contract = ActivityResultContracts.RequestMultiplePermissions(),&#10;        onResult = { perms -&gt;&#10;            hasLocationPermission = perms[Manifest.permission.ACCESS_FINE_LOCATION] == true || perms[Manifest.permission.ACCESS_COARSE_LOCATION] == true&#10;        }&#10;    )&#10;&#10;    // MapView is created inside AndroidView. Keep a reference to call methods from Kotlin code.&#10;    var mapViewRef by remember { mutableStateOf&lt;MapView?&gt;(null) }&#10;&#10;    // Observe UI state from ViewModel&#10;    val uiState by viewModel.uiState.collectAsState()&#10;&#10;    // Initialize osmdroid configuration&#10;    LaunchedEffect(Unit) {&#10;        Configuration.getInstance().load(context, context.getSharedPreferences(&quot;osmdroid&quot;, Context.MODE_PRIVATE))&#10;    }&#10;&#10;    // Request permission once when composable enters composition (if not granted)&#10;    LaunchedEffect(hasLocationPermission) {&#10;        if (!hasLocationPermission) {&#10;            permissionLauncher.launch(arrayOf(Manifest.permission.ACCESS_FINE_LOCATION, Manifest.permission.ACCESS_COARSE_LOCATION))&#10;        }&#10;    }&#10;&#10;    // Track which stop was clicked for line directions&#10;    var selectedStopId by remember { mutableStateOf&lt;String?&gt;(null) }&#10;&#10;    // Update map markers when nearby stops change&#10;    LaunchedEffect(uiState.nearbyStops) {&#10;        mapViewRef?.let { mapView -&gt;&#10;            // Remove previous stop markers (keep &quot;You are here&quot; marker)&#10;            val overlaysToRemove = mapView.overlays.filter { it is Marker &amp;&amp; it.title != &quot;You are here&quot; }&#10;            overlaysToRemove.forEach { mapView.overlays.remove(it) }&#10;&#10;            // Add markers for each nearby stop&#10;            uiState.nearbyStops.forEach { stop -&gt;&#10;                val gp = GeoPoint(stop.latitude, stop.longitude)&#10;                val marker = Marker(mapView).apply {&#10;                    position = gp&#10;                    setAnchor(Marker.ANCHOR_CENTER, Marker.ANCHOR_BOTTOM)&#10;                    title = stop.name&#10;                    snippet = &quot;Stop ID: ${stop.id}&quot;&#10;                    icon = ContextCompat.getDrawable(context, R.drawable.bus_stop)&#10;                    &#10;                    // Store the stop ID in the marker's related object for unique identification&#10;                    relatedObject = stop.id&#10;&#10;                    // Set click listener to fetch and show line directions&#10;                    setOnMarkerClickListener { _, _ -&gt;&#10;                        selectedStopId = stop.id&#10;                        viewModel.fetchLineDirectionsForStop(stop.id)&#10;                        // Show the info window immediately&#10;                        showInfoWindow()&#10;                        true&#10;                    }&#10;                }&#10;                mapView.overlays.add(marker)&#10;            }&#10;            mapView.invalidate()&#10;        }&#10;    }&#10;&#10;    // Update marker snippet when line directions are loaded&#10;    LaunchedEffect(uiState.selectedStopLineDirections, selectedStopId) {&#10;        if (uiState.selectedStopLineDirections.isNotEmpty() &amp;&amp; selectedStopId != null) {&#10;            mapViewRef?.let { mapView -&gt;&#10;                // Find the marker for the selected stop using the unique stop ID&#10;                mapView.overlays.filterIsInstance&lt;Marker&gt;()&#10;                    .find { marker -&gt;&#10;                        marker.relatedObject == selectedStopId&#10;                    }?.let { marker -&gt;&#10;                        val stop = uiState.nearbyStops.find { it.id == selectedStopId }&#10;                        if (stop != null) {&#10;                            val lineDirections = uiState.selectedStopLineDirections&#10;                            val linesInfo = lineDirections.joinToString(&quot;\n&quot;) { line -&gt;&#10;                                &quot;${line.lijnnummer} from ${line.from} to ${line.to}&quot;&#10;                            }&#10;                            marker.snippet = stop.id&#10;                            // Show the updated info window&#10;                            marker.showInfoWindow()&#10;                        }&#10;                    }&#10;                mapView.invalidate()&#10;            }&#10;        }&#10;    }&#10;&#10;    Surface(modifier = Modifier.fillMaxSize()) {&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(0.dp),&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.Top&#10;        ) {&#10;&#10;            Box(modifier = Modifier&#10;                .fillMaxWidth()&#10;                .weight(1f)) {&#10;&#10;                AndroidView(&#10;                    factory = { ctx -&gt;&#10;                        val mv = MapView(ctx).apply {&#10;                            setTileSource(TileSourceFactory.MAPNIK)&#10;                            setMultiTouchControls(true)&#10;                            controller.setZoom(15.0)&#10;                        }&#10;                        mapViewRef = mv&#10;                        mv&#10;                    },&#10;                    update = { mv -&gt;&#10;                        mapViewRef = mv&#10;                        // If we have permission, try to get last location and center map&#10;                        if (hasLocationPermission &amp;&amp; activity != null) {&#10;                            val fused = LocationServices.getFusedLocationProviderClient(activity)&#10;                            try {&#10;                                fused.lastLocation.addOnSuccessListener { location: Location? -&gt;&#10;                                    location?.let { loc -&gt;&#10;                                        moveMapToLocation(mv, loc)&#10;                                        // Load cached stops first then fetch live stops using live GPS coordinates&#10;                                        viewModel.loadStopsForLocation(loc.latitude, loc.longitude)&#10;                                    }&#10;                                }&#10;                            } catch (_: SecurityException) {&#10;                                // ignore - permission should be checked before calling&#10;                            }&#10;                        }&#10;                    },&#10;                    modifier = Modifier.fillMaxSize()&#10;                )&#10;&#10;                // Show loading indicator&#10;                if (uiState.isLoading) {&#10;                    Box(&#10;                        modifier = Modifier.fillMaxSize(),&#10;                        contentAlignment = Alignment.Center&#10;                    ) {&#10;                        CircularProgressIndicator()&#10;                    }&#10;                }&#10;&#10;                // Show error message&#10;                uiState.error?.let { error -&gt;&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .fillMaxSize()&#10;                            .padding(16.dp),&#10;                        contentAlignment = Alignment.TopCenter&#10;                    ) {&#10;                        Card(&#10;                            colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.errorContainer)&#10;                        ) {&#10;                            Text(&#10;                                text = error,&#10;                                modifier = Modifier.padding(16.dp),&#10;                                color = MaterialTheme.colorScheme.onErrorContainer&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;&#10;                // Bottom sheet overlayed on top of the map&#10;                BottomSheet(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .align(Alignment.BottomCenter)&#10;                )&#10;            }&#10;&#10;            if (!hasLocationPermission) {&#10;                Text(&#10;                    text = &quot;Location permission required to show your position on the map.&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium,&#10;                    modifier = Modifier.padding(16.dp)&#10;                )&#10;                Button(onClick = {&#10;                    permissionLauncher.launch(arrayOf(Manifest.permission.ACCESS_FINE_LOCATION, Manifest.permission.ACCESS_COARSE_LOCATION))&#10;                }, modifier = Modifier.padding(bottom = 16.dp)) {&#10;                    Text(&quot;Grant location&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;private fun moveMapToLocation(mapView: MapView, location: Location) {&#10;    val geo = GeoPoint(location.latitude, location.longitude)&#10;    mapView.controller.apply {&#10;        setZoom(18.0)&#10;        animateTo(geo)&#10;    }&#10;    // Remove previous user marker(s) we added&#10;    val iterator = mapView.overlays.iterator()&#10;    while (iterator.hasNext()) {&#10;        val overlay = iterator.next()&#10;        if (overlay is Marker &amp;&amp; overlay.title == &quot;You are here&quot;) {&#10;            iterator.remove()&#10;        }&#10;    }&#10;    val marker = Marker(mapView).apply {&#10;        position = geo&#10;        setAnchor(Marker.ANCHOR_CENTER, Marker.ANCHOR_BOTTOM)&#10;        title = &quot;You are here&quot;&#10;        icon = ContextCompat.getDrawable(mapView.context, R.drawable.user_live_gps)&#10;    }&#10;    mapView.overlays.add(marker)&#10;    mapView.invalidate()&#10;}" />
              <option name="updatedContent" value="package com.danieljm.delijn.ui.screens.stops&#10;&#10;import android.Manifest&#10;import android.app.Activity&#10;import android.content.Context&#10;import android.content.pm.PackageManager&#10;import android.location.Location&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.viewinterop.AndroidView&#10;import androidx.core.content.ContextCompat&#10;import com.google.android.gms.location.LocationServices&#10;import org.koin.androidx.compose.koinViewModel&#10;import org.osmdroid.config.Configuration&#10;import org.osmdroid.tileprovider.tilesource.TileSourceFactory&#10;import org.osmdroid.util.GeoPoint&#10;import org.osmdroid.views.MapView&#10;import org.osmdroid.views.overlay.Marker&#10;import com.danieljm.delijn.R&#10;import com.danieljm.delijn.ui.components.BottomSheet&#10;&#10;@Composable&#10;fun StopsScreen(&#10;    viewModel: StopsViewModel = koinViewModel()&#10;) {&#10;    val context = LocalContext.current&#10;    val activity = context as? Activity&#10;&#10;    // Track permission state&#10;    var hasLocationPermission by remember {&#10;        mutableStateOf(&#10;            ContextCompat.checkSelfPermission(context, Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED&#10;        )&#10;    }&#10;&#10;    val permissionLauncher = rememberLauncherForActivityResult(&#10;        contract = ActivityResultContracts.RequestMultiplePermissions(),&#10;        onResult = { perms -&gt;&#10;            hasLocationPermission = perms[Manifest.permission.ACCESS_FINE_LOCATION] == true || perms[Manifest.permission.ACCESS_COARSE_LOCATION] == true&#10;        }&#10;    )&#10;&#10;    // MapView is created inside AndroidView. Keep a reference to call methods from Kotlin code.&#10;    var mapViewRef by remember { mutableStateOf&lt;MapView?&gt;(null) }&#10;&#10;    // Observe UI state from ViewModel&#10;    val uiState by viewModel.uiState.collectAsState()&#10;&#10;    // Initialize osmdroid configuration&#10;    LaunchedEffect(Unit) {&#10;        Configuration.getInstance().load(context, context.getSharedPreferences(&quot;osmdroid&quot;, Context.MODE_PRIVATE))&#10;    }&#10;&#10;    // Request permission once when composable enters composition (if not granted)&#10;    LaunchedEffect(hasLocationPermission) {&#10;        if (!hasLocationPermission) {&#10;            permissionLauncher.launch(arrayOf(Manifest.permission.ACCESS_FINE_LOCATION, Manifest.permission.ACCESS_COARSE_LOCATION))&#10;        }&#10;    }&#10;&#10;    // Track which stop was clicked for line directions&#10;    var selectedStopId by remember { mutableStateOf&lt;String?&gt;(null) }&#10;&#10;    // Update map markers when nearby stops change&#10;    LaunchedEffect(uiState.nearbyStops) {&#10;        mapViewRef?.let { mapView -&gt;&#10;            // Remove previous stop markers (keep &quot;You are here&quot; marker)&#10;            val overlaysToRemove = mapView.overlays.filter { it is Marker &amp;&amp; it.title != &quot;You are here&quot; }&#10;            overlaysToRemove.forEach { mapView.overlays.remove(it) }&#10;&#10;            // Add markers for each nearby stop&#10;            uiState.nearbyStops.forEach { stop -&gt;&#10;                val gp = GeoPoint(stop.latitude, stop.longitude)&#10;                val marker = Marker(mapView).apply {&#10;                    position = gp&#10;                    setAnchor(Marker.ANCHOR_CENTER, Marker.ANCHOR_BOTTOM)&#10;                    title = stop.name&#10;                    snippet = &quot;Stop ID: ${stop.id}&quot;&#10;                    icon = ContextCompat.getDrawable(context, R.drawable.bus_stop)&#10;                    &#10;                    // Store the stop ID in the marker's related object for unique identification&#10;                    relatedObject = stop.id&#10;&#10;                    // Set click listener to fetch and show line directions&#10;                    setOnMarkerClickListener { _, _ -&gt;&#10;                        selectedStopId = stop.id&#10;                        viewModel.fetchLineDirectionsForStop(stop.id)&#10;                        // Show the info window immediately&#10;                        showInfoWindow()&#10;                        true&#10;                    }&#10;                }&#10;                mapView.overlays.add(marker)&#10;            }&#10;            mapView.invalidate()&#10;        }&#10;    }&#10;&#10;    // Update marker snippet when line directions are loaded&#10;    LaunchedEffect(uiState.selectedStopLineDirections, selectedStopId) {&#10;        if (uiState.selectedStopLineDirections.isNotEmpty() &amp;&amp; selectedStopId != null) {&#10;            mapViewRef?.let { mapView -&gt;&#10;                // Find the marker for the selected stop using the unique stop ID&#10;                mapView.overlays.filterIsInstance&lt;Marker&gt;()&#10;                    .find { marker -&gt;&#10;                        marker.relatedObject == selectedStopId&#10;                    }?.let { marker -&gt;&#10;                        val stop = uiState.nearbyStops.find { it.id == selectedStopId }&#10;                        if (stop != null) {&#10;                            val lineDirections = uiState.selectedStopLineDirections&#10;                            val linesInfo = lineDirections.joinToString(&quot;\n&quot;) { line -&gt;&#10;                                &quot;${line.lijnnummer} from ${line.from} to ${line.to}&quot;&#10;                            }&#10;                            marker.snippet = stop.id&#10;                            // Show the updated info window&#10;                            marker.showInfoWindow()&#10;                        }&#10;                    }&#10;                mapView.invalidate()&#10;            }&#10;        }&#10;    }&#10;&#10;    Surface(modifier = Modifier.fillMaxSize()) {&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(0.dp),&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.Top&#10;        ) {&#10;&#10;            Box(modifier = Modifier&#10;                .fillMaxWidth()&#10;                .weight(1f)) {&#10;&#10;                AndroidView(&#10;                    factory = { ctx -&gt;&#10;                        val mv = MapView(ctx).apply {&#10;                            setTileSource(TileSourceFactory.MAPNIK)&#10;                            setMultiTouchControls(true)&#10;                            controller.setZoom(15.0)&#10;                        }&#10;                        mapViewRef = mv&#10;                        mv&#10;                    },&#10;                    update = { mv -&gt;&#10;                        mapViewRef = mv&#10;                        // If we have permission, try to get last location and center map&#10;                        if (hasLocationPermission &amp;&amp; activity != null) {&#10;                            val fused = LocationServices.getFusedLocationProviderClient(activity)&#10;                            try {&#10;                                fused.lastLocation.addOnSuccessListener { location: Location? -&gt;&#10;                                    location?.let { loc -&gt;&#10;                                        moveMapToLocation(mv, loc)&#10;                                        // Load cached stops first then fetch live stops using live GPS coordinates&#10;                                        viewModel.loadStopsForLocation(loc.latitude, loc.longitude)&#10;                                    }&#10;                                }&#10;                            } catch (_: SecurityException) {&#10;                                // ignore - permission should be checked before calling&#10;                            }&#10;                        }&#10;                    },&#10;                    modifier = Modifier.fillMaxSize()&#10;                )&#10;&#10;                // Show loading indicator&#10;                if (uiState.isLoading) {&#10;                    Box(&#10;                        modifier = Modifier.fillMaxSize(),&#10;                        contentAlignment = Alignment.Center&#10;                    ) {&#10;                        CircularProgressIndicator()&#10;                    }&#10;                }&#10;&#10;                // Show error message&#10;                uiState.error?.let { error -&gt;&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .fillMaxSize()&#10;                            .padding(16.dp),&#10;                        contentAlignment = Alignment.TopCenter&#10;                    ) {&#10;                        Card(&#10;                            colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.errorContainer)&#10;                        ) {&#10;                            Text(&#10;                                text = error,&#10;                                modifier = Modifier.padding(16.dp),&#10;                                color = MaterialTheme.colorScheme.onErrorContainer&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;&#10;                // Bottom sheet overlayed on top of the map&#10;                BottomSheet(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .align(Alignment.BottomCenter)&#10;                )&#10;            }&#10;&#10;            if (!hasLocationPermission) {&#10;                Text(&#10;                    text = &quot;Location permission required to show your position on the map.&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium,&#10;                    modifier = Modifier.padding(16.dp)&#10;                )&#10;                Button(onClick = {&#10;                    permissionLauncher.launch(arrayOf(Manifest.permission.ACCESS_FINE_LOCATION, Manifest.permission.ACCESS_COARSE_LOCATION))&#10;                }, modifier = Modifier.padding(bottom = 16.dp)) {&#10;                    Text(&quot;Grant location&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;private fun moveMapToLocation(mapView: MapView, location: Location) {&#10;    val geo = GeoPoint(location.latitude, location.longitude)&#10;    mapView.controller.apply {&#10;        setZoom(18.0)&#10;        animateTo(geo)&#10;    }&#10;    // Remove previous user marker(s) we added&#10;    val iterator = mapView.overlays.iterator()&#10;    while (iterator.hasNext()) {&#10;        val overlay = iterator.next()&#10;        if (overlay is Marker &amp;&amp; overlay.title == &quot;You are here&quot;) {&#10;            iterator.remove()&#10;        }&#10;    }&#10;    val marker = Marker(mapView).apply {&#10;        position = geo&#10;        setAnchor(Marker.ANCHOR_CENTER, Marker.ANCHOR_BOTTOM)&#10;        title = &quot;You are here&quot;&#10;        icon = ContextCompat.getDrawable(mapView.context, R.drawable.user_live_gps)&#10;    }&#10;    mapView.overlays.add(marker)&#10;    mapView.invalidate()&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>