<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/AndroidManifest.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/AndroidManifest.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#10;&#10;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot; /&gt;&#10;&#10;    &lt;application&#10;        android:name=&quot;.DeLijnApp&quot;&#10;        android:allowBackup=&quot;true&quot;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/Theme.DeLijn&quot;&gt;&#10;        &lt;activity&#10;            android:name=&quot;.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:label=&quot;@string/app_name&quot;&#10;            android:theme=&quot;@style/Theme.DeLijn&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;    &lt;/application&gt;&#10;&#10;&lt;/manifest&gt;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#10;&#10;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot; /&gt;&#10;&#10;    &lt;application&#10;        android:name=&quot;.DeLijnApp&quot;&#10;        android:allowBackup=&quot;true&quot;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/Theme.DeLijn&quot;&gt;&#10;        &lt;activity&#10;            android:name=&quot;.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:label=&quot;@string/app_name&quot;&#10;            android:theme=&quot;@style/Theme.DeLijn&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;    &lt;/application&gt;&#10;&#10;&lt;/manifest&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/danieljm/delijn/ui/screens/stops/StopsScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/danieljm/delijn/ui/screens/stops/StopsScreen.kt" />
              <option name="originalContent" value="package com.danieljm.delijn.ui.screens.stops&#10;&#10;import android.Manifest&#10;import android.content.Context&#10;import android.content.pm.PackageManager&#10;import android.location.Location&#10;import android.net.Uri&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.compose.animation.core.Animatable&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.lazy.rememberLazyListState&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.Card&#10;import androidx.compose.material3.CardDefaults&#10;import androidx.compose.material3.FloatingActionButton&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Surface&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.DisposableEffect&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.runtime.saveable.Saver&#10;import androidx.compose.runtime.saveable.rememberSaveable&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.unit.Dp&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.viewinterop.AndroidView&#10;import androidx.core.content.ContextCompat&#10;import com.composables.icons.lucide.Lucide&#10;import com.composables.icons.lucide.Navigation&#10;import com.danieljm.delijn.R&#10;import com.danieljm.delijn.ui.components.stops.BottomSheet&#10;import com.danieljm.delijn.ui.navigation.Screen&#10;import kotlinx.coroutines.launch&#10;import org.koin.androidx.compose.koinViewModel&#10;import org.osmdroid.config.Configuration&#10;import org.osmdroid.tileprovider.tilesource.TileSourceFactory&#10;import org.osmdroid.util.GeoPoint&#10;import org.osmdroid.views.MapView&#10;import org.osmdroid.views.overlay.Marker&#10;import androidx.navigation.NavHostController&#10;&#10;@Composable&#10;fun StopsScreen(&#10;    navController: NavHostController,&#10;    viewModel: StopsViewModel = koinViewModel()&#10;) {&#10;    val context = LocalContext.current&#10;    val uiState by viewModel.uiState.collectAsState()&#10;    val userLocation = uiState.userLocation&#10;&#10;    var hasLocationPermission by remember {&#10;        mutableStateOf(&#10;            ContextCompat.checkSelfPermission(context, Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED&#10;        )&#10;    }&#10;&#10;    val permissionLauncher = rememberLauncherForActivityResult(&#10;        contract = ActivityResultContracts.RequestMultiplePermissions(),&#10;        onResult = { perms -&gt;&#10;            val permissionGranted = perms[Manifest.permission.ACCESS_FINE_LOCATION] == true || perms[Manifest.permission.ACCESS_COARSE_LOCATION] == true&#10;            hasLocationPermission = permissionGranted&#10;        }&#10;    )&#10;&#10;    var mapViewRef by remember { mutableStateOf&lt;MapView?&gt;(null) }&#10;    val DpSaver = Saver&lt;Dp, Float&gt;(&#10;        save = { it.value },&#10;        restore = { it.dp }&#10;    )&#10;    var bottomSheetHeight by rememberSaveable(stateSaver = DpSaver) { mutableStateOf(160.dp) }&#10;    var selectedStopId by remember { mutableStateOf&lt;String?&gt;(null) }&#10;    var pendingCenterOnLocation by remember { mutableStateOf(false) }&#10;    var isFirstLaunch by rememberSaveable { mutableStateOf(true) }&#10;    val coroutineScope = rememberCoroutineScope()&#10;&#10;    // Initialize osmdroid configuration&#10;    LaunchedEffect(Unit) {&#10;        Configuration.getInstance().load(context, context.getSharedPreferences(&quot;osmdroid&quot;, Context.MODE_PRIVATE))&#10;    }&#10;&#10;    // Request permission or location once when the screen is first composed&#10;    LaunchedEffect(hasLocationPermission) {&#10;        if (hasLocationPermission) {&#10;            viewModel.startLocationUpdates(context)&#10;        } else {&#10;            permissionLauncher.launch(arrayOf(Manifest.permission.ACCESS_FINE_LOCATION, Manifest.permission.ACCESS_COARSE_LOCATION))&#10;        }&#10;    }&#10;&#10;    // Center map on user location only on first launch or when explicitly requested&#10;    LaunchedEffect(isFirstLaunch, userLocation) {&#10;        if (isFirstLaunch &amp;&amp; userLocation != null) {&#10;            moveMapToLocation(mapViewRef, userLocation, isInitialMove = true)&#10;            isFirstLaunch = false&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(pendingCenterOnLocation, userLocation) {&#10;        if (pendingCenterOnLocation &amp;&amp; userLocation != null) {&#10;            moveMapToLocation(mapViewRef, userLocation, isInitialMove = true)&#10;            pendingCenterOnLocation = false&#10;        }&#10;    }&#10;&#10;    // Animate the user's location marker smoothly&#10;    LaunchedEffect(userLocation, mapViewRef) {&#10;        if (userLocation != null &amp;&amp; mapViewRef != null) {&#10;            val oldMarker = mapViewRef!!.overlays.filterIsInstance&lt;Marker&gt;().find { it.title == &quot;You are here&quot; }&#10;            val newGeoPoint = GeoPoint(userLocation.latitude, userLocation.longitude)&#10;&#10;            if (oldMarker == null) {&#10;                // Initial placement of the marker&#10;                val marker = Marker(mapViewRef).apply {&#10;                    position = newGeoPoint&#10;                    setAnchor(Marker.ANCHOR_CENTER, Marker.ANCHOR_BOTTOM)&#10;                    title = &quot;You are here&quot;&#10;                    icon = ContextCompat.getDrawable(mapViewRef!!.context, R.drawable.user_live_dot)&#10;                }&#10;                mapViewRef!!.overlays.add(marker)&#10;                mapViewRef!!.invalidate()&#10;            } else {&#10;                // Animate the existing marker to the new position&#10;                val startPoint = oldMarker.position&#10;                val endPoint = newGeoPoint&#10;&#10;                val latAnimatable = Animatable(startPoint.latitude.toFloat())&#10;                val lonAnimatable = Animatable(startPoint.longitude.toFloat())&#10;&#10;                coroutineScope.launch {&#10;                    launch {&#10;                        latAnimatable.animateTo(endPoint.latitude.toFloat(), animationSpec = tween(1000)) {&#10;                            oldMarker.position.latitude = value.toDouble()&#10;                            mapViewRef?.invalidate()&#10;                        }&#10;                    }&#10;                    launch {&#10;                        lonAnimatable.animateTo(endPoint.longitude.toFloat(), animationSpec = tween(1000)) {&#10;                            oldMarker.position.longitude = value.toDouble()&#10;                            mapViewRef?.invalidate()&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;&#10;    LaunchedEffect(uiState.nearbyStops) {&#10;        mapViewRef?.let { mapView -&gt;&#10;            // Remove previous stop markers (keep &quot;You are here&quot; marker)&#10;            val overlaysToRemove = mapView.overlays.filter { it is Marker &amp;&amp; it.title != &quot;You are here&quot; }&#10;            overlaysToRemove.forEach { mapView.overlays.remove(it) }&#10;&#10;            // Add markers for each nearby stop&#10;            uiState.nearbyStops.forEach { stop -&gt;&#10;                val gp = GeoPoint(stop.latitude, stop.longitude)&#10;                val marker = Marker(mapView).apply {&#10;                    position = gp&#10;                    setAnchor(Marker.ANCHOR_CENTER, Marker.ANCHOR_BOTTOM)&#10;                    title = stop.name&#10;                    snippet = &quot;Stop ID: ${stop.id}&quot;&#10;                    icon = ContextCompat.getDrawable(context, R.drawable.bus_stop)&#10;                    relatedObject = stop.id&#10;                    setOnMarkerClickListener { _, _ -&gt;&#10;                        navController.navigate(&quot;stopDetail/${stop.id}/${Uri.encode(stop.name)}&quot;)&#10;                        true&#10;                    }&#10;                }&#10;                mapView.overlays.add(marker)&#10;            }&#10;            mapView.invalidate()&#10;        }&#10;    }&#10;&#10;    // Update marker snippet when line directions are loaded&#10;    LaunchedEffect(uiState.selectedStopLineDirections, selectedStopId) {&#10;        if (uiState.selectedStopLineDirections.isNotEmpty() &amp;&amp; selectedStopId != null) {&#10;            mapViewRef?.let { mapView -&gt;&#10;                mapView.overlays.filterIsInstance&lt;Marker&gt;()&#10;                    .find { marker -&gt;&#10;                        marker.relatedObject == selectedStopId&#10;                    }?.let { marker -&gt;&#10;                        val stop = uiState.nearbyStops.find { it.id == selectedStopId }&#10;                        if (stop != null) {&#10;                            marker.snippet = stop.id&#10;                            marker.showInfoWindow()&#10;                        }&#10;                    }&#10;                mapView.invalidate()&#10;            }&#10;        }&#10;    }&#10;&#10;    var mapZoom by rememberSaveable { mutableStateOf(15.0) }&#10;    val stopsListState = rememberLazyListState() // Correctly using rememberLazyListState&#10;&#10;    DisposableEffect(mapViewRef) {&#10;        val mapView = mapViewRef&#10;        if (mapView != null) {&#10;            val listener = object : org.osmdroid.events.MapListener {&#10;                override fun onScroll(event: org.osmdroid.events.ScrollEvent?): Boolean {&#10;                    // not tracking map center in state to avoid hardcoded defaults&#10;                    return true&#10;                }&#10;                override fun onZoom(event: org.osmdroid.events.ZoomEvent?): Boolean {&#10;                    mapZoom = mapView.zoomLevelDouble&#10;                    return true&#10;                }&#10;            }&#10;            mapView.addMapListener(listener)&#10;            onDispose { mapView.removeMapListener(listener) }&#10;        } else {&#10;            onDispose { }&#10;        }&#10;    }&#10;&#10;    Surface(modifier = Modifier.fillMaxSize()) {&#10;        Column(&#10;            modifier = Modifier.fillMaxSize(),&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.Top&#10;        ) {&#10;            Box(modifier = Modifier&#10;                .fillMaxWidth()&#10;                .weight(1f)) {&#10;&#10;                AndroidView(&#10;                    factory = { ctx -&gt;&#10;                        MapView(ctx).apply {&#10;                            setTileSource(TileSourceFactory.MAPNIK)&#10;                            setMultiTouchControls(true)&#10;                            controller.setZoom(mapZoom)&#10;                            // Do not set a hardcoded center here. The map will be centered once we have the user's location.&#10;                            mapViewRef = this&#10;                        }&#10;                    },&#10;                    update = { mv -&gt;&#10;                        mapViewRef = mv&#10;                    },&#10;                    modifier = Modifier.fillMaxSize()&#10;                )&#10;&#10;                // Show loading indicator&#10;                if (uiState.isLoading) {&#10;                    Box(&#10;                        modifier = Modifier.fillMaxSize(),&#10;                        contentAlignment = Alignment.Center&#10;                    ) {&#10;                        // Keep commented for now&#10;                        //CircularProgressIndicator()&#10;                    }&#10;                }&#10;&#10;                // Show error message&#10;                uiState.error?.let {&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .fillMaxSize()&#10;                            .padding(16.dp),&#10;                        contentAlignment = Alignment.TopCenter&#10;                    ) {&#10;                        Card(&#10;                            colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.errorContainer)&#10;                        ) {&#10;                            Text(&#10;                                text = it,&#10;                                modifier = Modifier.padding(16.dp),&#10;                                color = MaterialTheme.colorScheme.onErrorContainer&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;&#10;                // Floating Action Button positioned above the bottom sheet&#10;                FloatingActionButton(&#10;                    onClick = {&#10;                        if (hasLocationPermission) {&#10;                            if (userLocation != null) {&#10;                                moveMapToLocation(mapViewRef, userLocation, isInitialMove = true)&#10;                            } else {&#10;                                viewModel.startLocationUpdates(context)&#10;                                pendingCenterOnLocation = true&#10;                            }&#10;                        } else {&#10;                            permissionLauncher.launch(arrayOf(Manifest.permission.ACCESS_FINE_LOCATION, Manifest.permission.ACCESS_COARSE_LOCATION))&#10;                        }&#10;                    },&#10;                    containerColor = Color(0xFF1D2124),&#10;                    contentColor = Color(0xFFBDBDBD),&#10;                    shape = RoundedCornerShape(32.dp),&#10;                    modifier = Modifier&#10;                        .align(Alignment.BottomEnd)&#10;                        .padding(end = 16.dp, bottom = bottomSheetHeight + 16.dp)&#10;                ) {&#10;                    Icon(Lucide.Navigation, &quot;Center on my location&quot;)&#10;                }&#10;&#10;                // Bottom sheet overlayed on top of the map&#10;                BottomSheet(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .align(Alignment.BottomCenter),&#10;                    stops = uiState.nearbyStops,&#10;                    userLat = userLocation?.latitude,&#10;                    userLon = userLocation?.longitude,&#10;                    onHeightChanged = { height -&gt; bottomSheetHeight = height },&#10;                    onStopClick = { stop -&gt;&#10;                        mapViewRef?.controller?.animateTo(GeoPoint(stop.latitude, stop.longitude))&#10;                    },&#10;                    isLoading = uiState.isLoading,&#10;                    shouldAnimateRefresh = uiState.shouldAnimateRefresh,&#10;                    onRefresh = {&#10;                        if(hasLocationPermission) {&#10;                            // Use the new force refresh method instead&#10;                            viewModel.forceLocationUpdateAndRefresh(context)&#10;                        } else {&#10;                            permissionLauncher.launch(arrayOf(Manifest.permission.ACCESS_FINE_LOCATION, Manifest.permission.ACCESS_COARSE_LOCATION))&#10;                        }&#10;                    },&#10;                    onRefreshAnimationComplete = {&#10;                        viewModel.onRefreshAnimationComplete()&#10;                    },&#10;                    listState = stopsListState&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    // Always center map on user location as soon as it is available&#10;    LaunchedEffect(userLocation) {&#10;        if (userLocation != null &amp;&amp; mapViewRef != null) {&#10;            moveMapToLocation(mapViewRef, userLocation, isInitialMove = false)&#10;        }&#10;    }&#10;}&#10;&#10;private var lastCenteredLocation: Pair&lt;Double, Double&gt;? = null&#10;&#10;private fun moveMapToLocation(mapView: MapView?, location: Location?, isInitialMove: Boolean = false) {&#10;    if (mapView == null || location == null) return&#10;&#10;    val lat = location.latitude&#10;    val lon = location.longitude&#10;&#10;    if (!isInitialMove &amp;&amp; lastCenteredLocation?.first == lat &amp;&amp; lastCenteredLocation?.second == lon) {&#10;        return&#10;    }&#10;&#10;    lastCenteredLocation = lat to lon&#10;    val geo = GeoPoint(lat, lon)&#10;    mapView.controller.animateTo(geo)&#10;    if (isInitialMove) {&#10;        mapView.controller.setZoom(18.0)&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.danieljm.delijn.ui.screens.stops&#10;&#10;import android.Manifest&#10;import android.content.Context&#10;import android.content.pm.PackageManager&#10;import android.location.Location&#10;import android.net.Uri&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.compose.animation.core.Animatable&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.lazy.rememberLazyListState&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.Card&#10;import androidx.compose.material3.CardDefaults&#10;import androidx.compose.material3.FloatingActionButton&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Surface&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.DisposableEffect&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.runtime.saveable.Saver&#10;import androidx.compose.runtime.saveable.rememberSaveable&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.unit.Dp&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.viewinterop.AndroidView&#10;import androidx.core.content.ContextCompat&#10;import com.composables.icons.lucide.Lucide&#10;import com.composables.icons.lucide.Navigation&#10;import com.danieljm.delijn.R&#10;import com.danieljm.delijn.ui.components.stops.BottomSheet&#10;import com.danieljm.delijn.ui.navigation.Screen&#10;import kotlinx.coroutines.launch&#10;import org.koin.androidx.compose.koinViewModel&#10;import org.osmdroid.config.Configuration&#10;import org.osmdroid.tileprovider.tilesource.TileSourceFactory&#10;import org.osmdroid.util.GeoPoint&#10;import org.osmdroid.views.MapView&#10;import org.osmdroid.views.overlay.Marker&#10;import androidx.navigation.NavHostController&#10;&#10;@Composable&#10;fun StopsScreen(&#10;    navController: NavHostController,&#10;    viewModel: StopsViewModel = koinViewModel()&#10;) {&#10;    val context = LocalContext.current&#10;    val uiState by viewModel.uiState.collectAsState()&#10;    val userLocation = uiState.userLocation&#10;&#10;    var hasLocationPermission by remember {&#10;        mutableStateOf(&#10;            ContextCompat.checkSelfPermission(context, Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED&#10;        )&#10;    }&#10;&#10;    val permissionLauncher = rememberLauncherForActivityResult(&#10;        contract = ActivityResultContracts.RequestMultiplePermissions(),&#10;        onResult = { perms -&gt;&#10;            val permissionGranted = perms[Manifest.permission.ACCESS_FINE_LOCATION] == true || perms[Manifest.permission.ACCESS_COARSE_LOCATION] == true&#10;            hasLocationPermission = permissionGranted&#10;        }&#10;    )&#10;&#10;    var mapViewRef by remember { mutableStateOf&lt;MapView?&gt;(null) }&#10;    val DpSaver = Saver&lt;Dp, Float&gt;(&#10;        save = { it.value },&#10;        restore = { it.dp }&#10;    )&#10;    var bottomSheetHeight by rememberSaveable(stateSaver = DpSaver) { mutableStateOf(160.dp) }&#10;    var selectedStopId by remember { mutableStateOf&lt;String?&gt;(null) }&#10;    var pendingCenterOnLocation by remember { mutableStateOf(false) }&#10;    var isFirstLaunch by rememberSaveable { mutableStateOf(true) }&#10;    val coroutineScope = rememberCoroutineScope()&#10;&#10;    // Initialize osmdroid configuration&#10;    LaunchedEffect(Unit) {&#10;        Configuration.getInstance().load(context, context.getSharedPreferences(&quot;osmdroid&quot;, Context.MODE_PRIVATE))&#10;    }&#10;&#10;    // Request permission or location once when the screen is first composed&#10;    LaunchedEffect(hasLocationPermission) {&#10;        if (hasLocationPermission) {&#10;            viewModel.startLocationUpdates(context)&#10;        } else {&#10;            permissionLauncher.launch(arrayOf(Manifest.permission.ACCESS_FINE_LOCATION, Manifest.permission.ACCESS_COARSE_LOCATION))&#10;        }&#10;    }&#10;&#10;    // Center map on user location only on first launch or when explicitly requested&#10;    LaunchedEffect(isFirstLaunch, userLocation) {&#10;        if (isFirstLaunch &amp;&amp; userLocation != null) {&#10;            moveMapToLocation(mapViewRef, userLocation, isInitialMove = true)&#10;            isFirstLaunch = false&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(pendingCenterOnLocation, userLocation) {&#10;        if (pendingCenterOnLocation &amp;&amp; userLocation != null) {&#10;            moveMapToLocation(mapViewRef, userLocation, isInitialMove = true)&#10;            pendingCenterOnLocation = false&#10;        }&#10;    }&#10;&#10;    // Animate the user's location marker smoothly&#10;    LaunchedEffect(userLocation, mapViewRef) {&#10;        if (userLocation != null &amp;&amp; mapViewRef != null) {&#10;            val oldMarker = mapViewRef!!.overlays.filterIsInstance&lt;Marker&gt;().find { it.title == &quot;You are here&quot; }&#10;            val newGeoPoint = GeoPoint(userLocation.latitude, userLocation.longitude)&#10;&#10;            if (oldMarker == null) {&#10;                // Initial placement of the marker&#10;                val marker = Marker(mapViewRef).apply {&#10;                    position = newGeoPoint&#10;                    setAnchor(Marker.ANCHOR_CENTER, Marker.ANCHOR_BOTTOM)&#10;                    title = &quot;You are here&quot;&#10;                    icon = ContextCompat.getDrawable(mapViewRef!!.context, R.drawable.user_live_dot)&#10;                }&#10;                mapViewRef!!.overlays.add(marker)&#10;                mapViewRef!!.invalidate()&#10;            } else {&#10;                // Animate the existing marker to the new position&#10;                val startPoint = oldMarker.position&#10;                val endPoint = newGeoPoint&#10;&#10;                val latAnimatable = Animatable(startPoint.latitude.toFloat())&#10;                val lonAnimatable = Animatable(startPoint.longitude.toFloat())&#10;&#10;                coroutineScope.launch {&#10;                    launch {&#10;                        latAnimatable.animateTo(endPoint.latitude.toFloat(), animationSpec = tween(1000)) {&#10;                            oldMarker.position.latitude = value.toDouble()&#10;                            mapViewRef?.invalidate()&#10;                        }&#10;                    }&#10;                    launch {&#10;                        lonAnimatable.animateTo(endPoint.longitude.toFloat(), animationSpec = tween(1000)) {&#10;                            oldMarker.position.longitude = value.toDouble()&#10;                            mapViewRef?.invalidate()&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;&#10;    LaunchedEffect(uiState.nearbyStops) {&#10;        mapViewRef?.let { mapView -&gt;&#10;            // Remove previous stop markers (keep &quot;You are here&quot; marker)&#10;            val overlaysToRemove = mapView.overlays.filter { it is Marker &amp;&amp; it.title != &quot;You are here&quot; }&#10;            overlaysToRemove.forEach { mapView.overlays.remove(it) }&#10;&#10;            // Add markers for each nearby stop&#10;            uiState.nearbyStops.forEach { stop -&gt;&#10;                val gp = GeoPoint(stop.latitude, stop.longitude)&#10;                val marker = Marker(mapView).apply {&#10;                    position = gp&#10;                    setAnchor(Marker.ANCHOR_CENTER, Marker.ANCHOR_BOTTOM)&#10;                    title = stop.name&#10;                    snippet = &quot;Stop ID: ${stop.id}&quot;&#10;                    icon = ContextCompat.getDrawable(context, R.drawable.bus_stop)&#10;                    relatedObject = stop.id&#10;                    setOnMarkerClickListener { _, _ -&gt;&#10;                        navController.navigate(&quot;stopDetail/${stop.id}/${Uri.encode(stop.name)}&quot;)&#10;                        true&#10;                    }&#10;                }&#10;                mapView.overlays.add(marker)&#10;            }&#10;            mapView.invalidate()&#10;        }&#10;    }&#10;&#10;    // Update marker snippet when line directions are loaded&#10;    LaunchedEffect(uiState.selectedStopLineDirections, selectedStopId) {&#10;        if (uiState.selectedStopLineDirections.isNotEmpty() &amp;&amp; selectedStopId != null) {&#10;            mapViewRef?.let { mapView -&gt;&#10;                mapView.overlays.filterIsInstance&lt;Marker&gt;()&#10;                    .find { marker -&gt;&#10;                        marker.relatedObject == selectedStopId&#10;                    }?.let { marker -&gt;&#10;                        val stop = uiState.nearbyStops.find { it.id == selectedStopId }&#10;                        if (stop != null) {&#10;                            marker.snippet = stop.id&#10;                            marker.showInfoWindow()&#10;                        }&#10;                    }&#10;                mapView.invalidate()&#10;            }&#10;        }&#10;    }&#10;&#10;    var mapZoom by rememberSaveable { mutableStateOf(15.0) }&#10;    val stopsListState = rememberLazyListState() // Correctly using rememberLazyListState&#10;&#10;    DisposableEffect(mapViewRef) {&#10;        val mapView = mapViewRef&#10;        if (mapView != null) {&#10;            val listener = object : org.osmdroid.events.MapListener {&#10;                override fun onScroll(event: org.osmdroid.events.ScrollEvent?): Boolean {&#10;                    // not tracking map center in state to avoid hardcoded defaults&#10;                    return true&#10;                }&#10;                override fun onZoom(event: org.osmdroid.events.ZoomEvent?): Boolean {&#10;                    mapZoom = mapView.zoomLevelDouble&#10;                    return true&#10;                }&#10;            }&#10;            mapView.addMapListener(listener)&#10;            onDispose { mapView.removeMapListener(listener) }&#10;        } else {&#10;            onDispose { }&#10;        }&#10;    }&#10;&#10;    Surface(modifier = Modifier.fillMaxSize()) {&#10;        Column(&#10;            modifier = Modifier.fillMaxSize(),&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.Top&#10;        ) {&#10;            Box(modifier = Modifier&#10;                .fillMaxWidth()&#10;                .weight(1f)) {&#10;&#10;                AndroidView(&#10;                    factory = { ctx -&gt;&#10;                        MapView(ctx).apply {&#10;                            setTileSource(TileSourceFactory.MAPNIK)&#10;                            setMultiTouchControls(true)&#10;                            controller.setZoom(mapZoom)&#10;                            // Do not set a hardcoded center here. The map will be centered once we have the user's location.&#10;                            mapViewRef = this&#10;                        }&#10;                    },&#10;                    update = { mv -&gt;&#10;                        mapViewRef = mv&#10;                    },&#10;                    modifier = Modifier.fillMaxSize()&#10;                )&#10;&#10;                // Show loading indicator&#10;                if (uiState.isLoading) {&#10;                    Box(&#10;                        modifier = Modifier.fillMaxSize(),&#10;                        contentAlignment = Alignment.Center&#10;                    ) {&#10;                        // Keep commented for now&#10;                        //CircularProgressIndicator()&#10;                    }&#10;                }&#10;&#10;                // Show error message&#10;                uiState.error?.let {&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .fillMaxSize()&#10;                            .padding(16.dp),&#10;                        contentAlignment = Alignment.TopCenter&#10;                    ) {&#10;                        Card(&#10;                            colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.errorContainer)&#10;                        ) {&#10;                            Text(&#10;                                text = it,&#10;                                modifier = Modifier.padding(16.dp),&#10;                                color = MaterialTheme.colorScheme.onErrorContainer&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;&#10;                // Floating Action Button positioned above the bottom sheet&#10;                FloatingActionButton(&#10;                    onClick = {&#10;                        if (hasLocationPermission) {&#10;                            if (userLocation != null) {&#10;                                moveMapToLocation(mapViewRef, userLocation, isInitialMove = true)&#10;                            } else {&#10;                                viewModel.startLocationUpdates(context)&#10;                                pendingCenterOnLocation = true&#10;                            }&#10;                        } else {&#10;                            permissionLauncher.launch(arrayOf(Manifest.permission.ACCESS_FINE_LOCATION, Manifest.permission.ACCESS_COARSE_LOCATION))&#10;                        }&#10;                    },&#10;                    containerColor = Color(0xFF1D2124),&#10;                    contentColor = Color(0xFFBDBDBD),&#10;                    shape = RoundedCornerShape(32.dp),&#10;                    modifier = Modifier&#10;                        .align(Alignment.BottomEnd)&#10;                        .padding(end = 16.dp, bottom = bottomSheetHeight + 16.dp)&#10;                ) {&#10;                    Icon(Lucide.Navigation, &quot;Center on my location&quot;)&#10;                }&#10;&#10;                // Bottom sheet overlayed on top of the map&#10;                BottomSheet(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .align(Alignment.BottomCenter),&#10;                    stops = uiState.nearbyStops,&#10;                    userLat = userLocation?.latitude,&#10;                    userLon = userLocation?.longitude,&#10;                    onHeightChanged = { height -&gt; bottomSheetHeight = height },&#10;                    onStopClick = { stop -&gt;&#10;                        mapViewRef?.controller?.animateTo(GeoPoint(stop.latitude, stop.longitude))&#10;                    },&#10;                    isLoading = uiState.isLoading,&#10;                    shouldAnimateRefresh = uiState.shouldAnimateRefresh,&#10;                    onRefresh = {&#10;                        if(hasLocationPermission) {&#10;                            // Use the new force refresh method instead&#10;                            viewModel.forceLocationUpdateAndRefresh(context)&#10;                        } else {&#10;                            permissionLauncher.launch(arrayOf(Manifest.permission.ACCESS_FINE_LOCATION, Manifest.permission.ACCESS_COARSE_LOCATION))&#10;                        }&#10;                    },&#10;                    onRefreshAnimationComplete = {&#10;                        viewModel.onRefreshAnimationComplete()&#10;                    },&#10;                    listState = stopsListState&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    // Always center map on user location as soon as it is available&#10;    LaunchedEffect(userLocation) {&#10;        if (userLocation != null &amp;&amp; mapViewRef != null) {&#10;            moveMapToLocation(mapViewRef, userLocation, isInitialMove = false)&#10;        }&#10;    }&#10;}&#10;&#10;private var lastCenteredLocation: Pair&lt;Double, Double&gt;? = null&#10;&#10;private fun moveMapToLocation(mapView: MapView?, location: Location?, isInitialMove: Boolean = false) {&#10;    if (mapView == null || location == null) return&#10;&#10;    val lat = location.latitude&#10;    val lon = location.longitude&#10;&#10;    if (!isInitialMove &amp;&amp; lastCenteredLocation?.first == lat &amp;&amp; lastCenteredLocation?.second == lon) {&#10;        return&#10;    }&#10;&#10;    lastCenteredLocation = lat to lon&#10;    val geo = GeoPoint(lat, lon)&#10;    mapView.controller.animateTo(geo)&#10;    if (isInitialMove) {&#10;        mapView.controller.setZoom(18.0)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>